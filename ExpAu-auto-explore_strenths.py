"""
1.случайно выбираем точку для выращивания А (чтото темное)
2.в окрестности этой точки случайно создаем несолько небинарных экспериментов простого вида (на том же эталоне)
3.загружаем тестовое и трейновое можество картинок-троек
4.для каждого из управлений строим график зависимости предстказтельной силы А на данное ю
 от параметров А (именно, от радиуса события). Замер проводим с исп. трейна и теста.
5.по полученным графикам для каждого из них оцениваем скалярную величину "полезность А".
 интуиция: чем больше помогает факт, что А=1, в деле предскаания исхода ю
 (по сравнению с отсутствием знания этого факта),
 тем выше минимальная доказанная полезность факта А=1.
 Геометрически: чем ниже линия графика Аu (она ломанаая) по сравнению с прямой линией ю, тем лучше. Если она выше,
  то ноль. Если колеблется вокруг нее, то тоже ноль.
6. К этому моменту имеется несколько управлений, и для каждого из них полезность А(число).
Визуализируем всех их на картинке-эталоне, соединяя центр А с чентром ю линией,
 толщина которой задается полезностью.
 Плюс, в лог должны попаасть все графики ю от е-рад и число полезности А для кадого их них, чтоб выидеть
  адектватность работы.
  Плюс, крастной точкой нарисовать рез-т сработывания п.7):
7*) написать функцию, которая будет выбирать оптимаьный е_рад: самый большой, начиная с котрого полезность нулевая.
Самый большой это чтоб не отсечь линее и не задать слишком строгое условие.
Результаты:
А) окажется, что самые толстые линии соединяют А с ближайшими точками окружения (нет дальнодействия).
Б) Величина должна оказаться ноль для тех точек, где график ошибки u(e_rad) лежит вцелом не ниже,
 чем линия u безусловная.

Зачем: после отладки этого кода мы получим автоматическое задание первого бинарного юнита.
Причем для этого юнита будет введена минимальня оценка его полезности.
В словарь известных полезных сущностей (читай, в долговременную память) внесен бинарный детектор А.
К нему уже можно наращивать другие детекторы.
Теперь в окрестности срабатывания конктетного экземпляра А на эталоне можно огляжеться вокруг в
поисках срабатывания А в окрестностях этой точки, и выбирать один из них и в качестве заготовки под
добавляемого бинарника Б, и/или в качестве управления-основания этого добавления.
"""
from data import *
from logger import *
from binary import *

def try_create_A_from_point(etalon_pic, x,y, sens_rad,  pics_train, pics_test):
    return A, u, sprofit

def
def try_different_simple_us_to_A():
    us = []
    Au_strenths = []
    A_e_rads = []

    for _ in range(10):
        u = select_random_simple_u_near_point(etalon_pic, Ax, Ay)
        Au_connection_strenth, A_e_rad = adjast_A_e_rad_by_u(A, u, pics_test, pics_train)

        us.append[u]
        Au_strenths.append(Au_connection_strenth)
        A_e_rads.append(A_e_rad)
    return us, Au_strenths, A_e_rads

def get_best_Au_pair(us, Au_strenths, A_e_rads):
    best_u =
    best_e_rad =
    return best_u, best_e_rad


if __name__ == "__main__":
    logger = HtmlLogger("18exp")

    etalon_pic, pics_train, pics_test  = get_all_data3()

    Ax, Ay = select_random_rare_point_for_A(etalon_pic)
    A_sens_rad = 1
    A, u, sprofit = try_create_A_from_point(etalon_pic, Ax, Ay, A_sens_rad, pics_train, pics_test)





    B = select_random_comlex_u_near_point(etalon_pic, Ax, Ay)



    logger.close()
